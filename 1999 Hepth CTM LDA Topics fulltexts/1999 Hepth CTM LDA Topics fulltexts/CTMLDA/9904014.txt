9 9 9 1 r p 2 1 v 4 1 0 4 0 9 9 / h - p e h : v x r runge-kutta methods renormalization ch. brouder laboratoire de mineralogie cristallographie universites paris 6, paris 7, ipgp, case 115, 4 place jussieu 75252 paris cedex 05, france february 1, 2008 abstract connection algebra rooted trees used renormalization theory runge-kutta methods pointed out. butchers group b-series shown provide suitable framework renormalizing toy model eld theory, following kreimers ap- proach. finally b-series used solve class non-linear partial dierential equations. 1 introduction purpose paper point link two apparently remote concepts: renormalization runge-kutta methods. renormalization enables us remove innities quantum eld theory. recently, kreimer discovered hopf algebra rooted trees brings order beauty in- tricate combinatorics renormalization . established formulas automate subtraction innities orders perturbation expansion, proved eective- ness method practical computation renormalized quantities joint works broadhurst {$9810087$} delbourgo {$9903249$}. moreover, approach shines new light problem overlapping divergences  mechanics renormalization group {$9901099$}. furthermore, connes kreimer revealed deep connection algebra rooted trees (art) hopf algebra dieomorphisms . hand, runge published 1895  ecient algorithm compute solution ordinary dierential equations. equation type dy/ds = f (y(s)), denes recursively k1 = f (yn), k2 = f (yn + hk1/2), yn+1 = yn + hk2. algorithm improved 1901 kutta, became known runge-kutta method. one widely used numerical methods. 1972, butcher published extraordinary article analyzed general runge- kutta methods basis art. showed runge-kutta methods form group1 found explicit expressions inverse method product two methods. also dened sums trees called b-series honour butcher. altough hopf algebra structure art implicit along paper, butcher important developments made 1974 hairer wanner . mention it2. since then, b-series used routinely analysis runge-kutta methods. main purpose show results concepts established kreimer nicely runge-kutta language, tools developed butcher range application much wider numerical analysis ordinary dierential equations. 1hairer wanner called butcher group . 2the opposite present hopf structure art discussed 1986 dur (, p.88-90), together corresponding lie algebra (identical, sign, one dened ). 1 2.1 operations functions trees trees may appear multiplicity. present expository paper reasonably self-contained. introduction rooted trees, genetic relation art dierentials presented. butchers approach runge-kutta methods sketched. several b-series calculated connection hopf structure art exhibited. application runge-kutta methods renormalization exposed using toy model solved non perturbatively. finally, solution non-linear partial dierential equations written formal b-series. 2 rooted trees important operation merging trees. t1, . . . ,tk trees, = b+(t1, t2, . . . , tk) dened tree obtained creating new vertex r joining roots t1, . . . ,tk r, becomes root t. operation also denoted = , avoid notation possible confusion commutators. rooted tree graph designated vertex called root unique path root vertex tree . several examples rooted trees given appendix, root black point vertices white points (the root top tree). length unique path vertex v root called level number vertex v. root level number 0. vertex v (except root), father v unique vertex v edge common v smaller level number. conversely, v son v. vertex sons leaf. rooted trees sometimes called pointed trees arborescences. tree one vertex is, tree zero vertex designated 1. leaf vertex t. example n (1) =, n () =, n () = + n () = + 2(cid:10). (cid:11)! = 1 , connes kreimer dened natural growth operator n trees: n (t) set |t| trees ti, ti tree |t| + 1 vertices obtained attaching additional number functions rooted trees dened independently several authors: |t| designates number vertices tree (alternative notation r(t), (t) #t). clearly, |b+(t1, t2, . . . , tk)| = |t1| + |t2| + + |tk| + 1. tree factorial t! dened recursively b+(t1, t2, . . . , tk)! = |b+(t1, t2, . . . , tk)| t1!t2! tk!. (an alternative notation (t)). notation t! taken kreimer {$9901099$} t! general- izes factorial number. besides t! also similarities product hooklengthes young diagram representation theory symmetric group {$9810087$}. examples may useful(cid:12)! = 2,(cid:13)! = 6,! = 12,(cid:15)! = 24,(cid:16)! = 4. 2.2 cm(t) cm (t) dened {$9901099$} number times tree appears n n(1) n = |t| number vertices t. literature ({$9903249$}, {$9810022$}, p.92, {$9810022$}, p.147), cm (t) written 2 (t) considered number heap-ordered trees shape t, heap- ordered tree shape labelling vertex (i.e. bijection vertices set numbers 0, 1, . . . |t| 1) labels decrease along path going vertex root. called monotonic labelling {$9810022$}, p.147. (cid:17) (cid:18) (cid:19) (n 1)! heap-ordered trees n vertices. seen recursive argument. take heap-ordered tree n vertices, make n labeled trees adding new vertex label n vertex t. created trees heap-ordered (because added vertex leaf labels smaller n). furthermore, heap-ordered trees created process set heap-ordered trees n vertices dierent. therefore, least n! heap-ordered trees n + 1 vertices. hand, heap-ordered tree n + 1 vertices, vertex labeled n leaf, therefore created heap-ordered tree n vertices adding leaf label n. exactly n! heap-ordered trees n + 1 vertices. shall give non combinatiorial proof fact sequel. since n (t) dened addition leaf vertices t, (t) number heap-ordered trees shape t. number calculated {$9903249$} (see also. {$9810022$}, p.92): (t) = |t|! t!st , st symmetry factor t, dened  {$9810022$} denoted (t). note simple correspondence permutations n 1 numbers heap-ordered trees. let (p1, . . . , pn1) permutation (1, . . . , n 1), p1 subroot, labeled p1 i=2 n 1 pj 1 j pj > pi, pi subroot, labeled pi otherwise, let pj rst number pj < pi, series pi1, pi2, . . . , p1, i-th vertex, labeled pi, linked pj line (p1, . . . , pn1) processed, subroots linked common root, labeled 0 hand, starting heap-ordered tree t, arranged set vertices given level number ordered labels increasing right left. permutation built gathering labels depth-rst search (backtracking) tree left right. instance, permutation corresponding three labeled trees example (312), (231) (213). finally, use term algebra rooted trees hopf algebra rooted trees because, thanks work butcher, hopf structure one aspect art. 3 dierentials rooted trees assume want solve equation (d/ds)x(s) = f , x(s0) = x0, real, x rn f smooth function rn rn , components f i(x). equation ow vector eld. 3 3.1 calculation n-th derivative let us write derivatives i-th component x(s) respect s: d2xi(s) ds2 = ds f i =xj f xj  dxj ds f xj =xj f j d3xi(s) ds3 = ds xj 2f f xj f j = xjk xjxk f j f k +xjk f xj  f j xk f k. simplied notation required. let f = f i kf f j1j2jk = xj1 xjk , dxi(s) ds summation indices appearing lower upper positions implicitly assumed. notation, write next term = f j f j d2xi(s) ds2 = f =(cid:20) (cid:21) l f l + f = f k f k j f j j f j d4xi(s) ds4 d3xi(s) ds3 = f j f j kf k, jkf jf k + f (cid:22) (cid:23) l f kf l + f jkf j klf kf l + 3f jklf jf kf l relation dierentials rooted tree established arthur cayley 1857 {$9901099$}. notation, one-to-one relation rooted tree n vertices term dnx(s)/dsn 3.2 elementary dierentials little bit formally, follow butcher ({$9810022$}, p.154.) call elementary dier- entials dened recursively rooted tree by: = f = f j1j2jk j1 t1 j2 t2 jk tk = b+(t1, t2, , tk). (1) using correspondence rooted trees dierential expressions, establish identity: n dt ds = n (t), n (t) natural growth operator rooted trees dened ref.. solution ow equation ds exp (s s0)|t| (t)t(s0), |t|! (2) x(s) = x0 +z = x0 +xt s0 4 |t| number vertices t, (t) called cm (t) {$9901099$}. 4 runge-kutta methods shall see sum trees appear quite naturally dierential equations. so, one given function assigns value (e.g. real, complex, vector) tree t, function f (t) = t. generally, answer no. consider function components equal (and denoted also ): ((cid:24)) = 1, ((cid:25)) = a, ((cid:26)) = b, i, f = 1, f j f j third gives f dierentials (i.e. functions reachable elementary dierentials rather narrow. cannot t) function f b 6= a2. k f k = b. rst two equations give pj f j = a, j = a2, cannot represented elementary fact, number j f j = f j f j kf k = pj f given function rooted trees, extend homomorphism algebra rooted trees linearity (tt) = (t)(t) componentwise product used right-hand side. vector ows enough span possible , general equation that? shall see now, answer runge-kutta methods. 4.1 butchers approach runge-kutta methods solve ow equation dx(s)/ds = f , ecient numerical algorithms known runge-kutta methods. determined matrix m-dimensional vector b, step vector xn dened function previous value xn1 by: xi = xn1 + h xn = xn1 + h aij f (xj) bjf (xj), xj=1 xj=1 range 1 m. matrix aij = 0 j method called explicit (because xi calculated explicitly), otherwise method implicit. 1963, butcher showed solution corresponding equations: xi(s) = x0 + (s s0) x(s) = x0 + (s s0) aijf (xj(s)) bjf (xj(s)), xj=1 xj=1 given xi(s) = x0 +xt x(s) = x0 +xt (s s0)|t| |t|! (s s0)|t| |t|! (t)t! xj=1 aijj(t)t(s0) (t)t!(t)t(s0). (3) series trees called b-series numerical analysis literature, honour john butcher ({$9810022$}, p.264). homomorphism dened recursively function 5 i((cid:27)) = 1 b, = 1, . . . , m: aij1 . . . aijk j1 (t1) . . . jk (tk) i(b+(t1 tk)) = xj1,...,jk xi=1 (t) = bii(t). comparing eqs.(2) (3) clear runge-kutta approximates solution original ow equation order n (t) = 1/t! trees n vertices. 1972 , butcher made progress. firstly showed runge-kutta meth- ods dense space rooted tree homomorphisms. precisely, showed given nite set trees t0 function t0 r, runge-kutta method (i.e. matrix vector b) corresponding agrees t0 (see also {$9810022$} p.167). 4.2 developments furthermore, butcher proved combinatorics used study runge-kutta methods 1963 {$9903249$} hiding algebra. (a,b) (a,b) two runge-kutta methods, corresponding homomorphisms , product homomorphism dened (in hopf algebra terms) ( )(t) = m. butcher proved derived runge-kutta methods form group. again, nicely interpreted within hopf structure art. instance, inverse element simply dened 1(t) = , antipode. concept inverse quite important practice since involved concept self-adjoint runge-kutta methods, long-term stability time-reversal symmetric problems ({$9810022$}, p.219). adjoint dened within approach (t) = (1)|t|. hand, butcher found explicit expression hopf operations art. given method (a,b) , expressed method (a,b) (s antipode) (simple) terms (a,b). moreover, ({$9810022$}, p.312 et sq.), (a,b) (a,b) two runge-kutta methods (with dimensions m, respectively), corresponding , method (a,b) corresponding convolution product ( ) aij = aij aij = aij aij = bj aij = 0 bi = bi bi = bi 1 1 j m, + 1 + + 1 + + 1 + m. + 1 j + m, 1 j m, 1 + 1 j + m, 1 m, 1974, hairer wanner ({$9810022$}, p.267) built upon work butcher proved following important result: denote b(, f ) = 1 +xt (s s0)|t| |t|! (t)t!(t)t(s0) (4) b(, b(, f )) = b( , f ), (5) b(, b(, f )) eq.(4), (t) replaced (t) replaced (t) (i.e. (t) calculate t, function b(, f )(s) instead function f (x(s))). words, group homomorphisms acts right functions f . 6 5 continuous limit seminal article , butcher restrict treatment nite sets indices. possible consider continuous limit runge-kutta methods. possible form integral equation, write artitrarily 0 1: xu(s) = x0 + (s s0)z 1 x(s) = x0 + (s s0)z 1 0 0 dva(u, v)f (xv(s)) b(u)duf (xu(s)), (s s0)|t| |t|! (s s0)|t| |t|! (t)t!z 1 0 dva(u, v)v(t)t(s0) (t)t!(t)t(s0). solution xu(s) = x0 +xt x(s) = x0 +xt u((cid:28)) = 1 homomorphism dened recursively function b: u(b+(t1 tk)) = z 1 (t) = z 1 0 0 du1a(u, u1)u1 (t1) z 1 0 dub(u)u(t). duka(u, uk)uk (tk) continuous rk-methods seem much used, except example butchers book ({$9810022$} p.325). 5.1 butchers example useful following results modied version butchers example. so, consider: xu(s) = x0 + (s s0)z u x(s) = x0 + (s s0)z 1 0 0 f dv f du, (6) corresponds a(u, v) = 1(v), b(u) = 1. runge-kutta method used sequel, referred simple integral method. take derivative eq.(6) respect u obtain du xu(s) = (s s0)f , xu(s) = y(s0 + (s s0)u), y(s) solution moreover f ds. s0 y(s) = x0 +z x(s) = x0 + (s s0)z 1 = x0 + (s s0)z 1 = x0 +z s0 0 0 7 f du f du f ds = y(s). u((cid:29)) = 1 corresponding homomorphism (t) dened u(b+(t1 tk)) = z u (t) = z 1 0 0 du1u1 (t1) z u 0 duu(t). dukuk (tk) using facts |b+(t1 tk)| = (|t1| + + |tk| + 1) b+(t1 tk)! = (|t1| + + |tk| + 1)t1! . . . tk! proved solutions equations u(t) = (t) = |t|u|t|1 t! 1 t! . introduce (t) = 1/t! eq.(3) obtain eq.(2). conrm solution equation x(s) = x0 +z s0 f ds x(s) = x0 +xt (s s0)|t| |t|! (t)t(s0). 5.2 first applications example already bring interesting applications. must start giving way calculate t(s0) simple case. 5.2.1 calculation t(s0) obtain specic results, must choose particular function f . simplest choice take vector function f , components f i(x) = f (pj xj /n ), n dimension vector space f series expansion f (s) = f (n)(0)sn n! . xn=0 denition eq.(1), one show recursively that, = 1, . . . , n , t(0) independent (and denoted t) = f (0) = f (k)(0)t1 t2 tk = b+(t1, t2, , tk). (7) ref.{$9901099$}, kreimer dened similar quantity, called bt. bt used synonymous. simplest case f (s) = exp s0 = 0, f (n)(0) = 1 = 1 trees t. 5.2.2 weighted sum rooted trees take f = exp, s0 = 0 x0 = 0 butchers example (see section 5.1), solve equation x(s) =z 0 expds 8 dierentiated give x(s) = exp(x(s)) x(0) = 0. solution x(s) = log(1 s) = sn n . xn=1 hand, corresponding homomorphism (t) = 1/t! b-series problem comparing last two results, nd x(s) = xt s|t| |t|! (t). (t) = (n 1)! x|t|=n words, number heap-ordered trees n vertices (n 1)!. 5.2.3 derivative inverse functions try extend last example arbitrary function f (x). equation solve becomes x(s) = f (x(s)) x(0) = 0. let x(s) =z 0 f ds, s(x) =z x 0 dy f (y) , gives us = s(x), x(s) = s1(s), s1 inverse function s. f = exp, s(x) = 1 exp(x) conrm x(s) = log(1 s). use result calculate derivatives function x(s), given inverse function s(x). this, dene f (x) = 1/s(x) and, using eq.(2), obtain x(n)(0) = x|t|=n (t)t, (8) calculated f (s) using eq.(7) section 5.2.1. method also calculated nd function f satisfying given values calculated f . instance, want = x|t|=n (t)t, (t)t = n!, x|t|=n must take f (s) = 1 + s2. 5.2.4 sums trees give examples sums trees, used sequel. instance, assume need compute (t) t! . = x|t|=n 9 term comes butcher series (t) = 1/(t!)2. since (t) square previous one, corresponding runge-kutta method realized tensor product two simple integral methods (see section 5.1). words a(u, u, v, v) = a(u, v)a(u, v) = 1(v)1(v) b(u, u) = b(u)b(u) = 1. runge-kutta method xuu (s) = x0 + (s s0)z u x(s) = x0 + (s s0)z 1 0 0 0 dvz u duz 1 0 dvf  duf . uu ((cid:30)) = 1 corresponding homomorphism (t) given uu (b+(t1 tk)) = z u (t) = z 1 0 0 0 du1z u duz 1 0 duuu (t). du1u1u 1 (t1) z u 0 dukz u 0 dukuk u k (tk) solutions equations uu (t) = |t|2(uu)|t|1 (t!)2 (t) = 1 (t!)2 , that, eq.(3) xuu (s) = x0 +xt (s s0)|t| (t)(uu)|t| |t|! t! t(s0). conclusion xuu (s) fact function uu u u. precisely, know general formula eq.(3) b-series solution x(s) = x0 + (s s0)r 1 0 dur 1 0 duf  x(s) = x0 +xt (s s0)|t| (t) |t|! t! t(s0), xuu (s) = x(s0 + (s s0)uu). use successive changes variables w = uu, v = s0 + (s s0)w v = s0 + (s s0)u nd duf  dwf  0 0 du x(s) = x0 + (s s0)z 1 = x0 + (s s0)z 1 = x0 +z 1 = x0 +z duz 1 u z u u z s0+(ss0)u v s0 z v du dv s0 s0 s0 0 0 0 dvf  dvf . initial values x0 = s0 = 0 gives us x(s) = z 0 dv v z v 0 10 dvf , (9) sx + x = f (x) x(0) = 0 x(0) = f (0). take f (x) = exp(x) nd sx + x = exp(x) x(0) = 0 x(0) = 1, x(s) = 2 log(1 s/2) = sn n2n1 . xn=1 comparing b-series obtain x(s) = xt s|t| |t|! (t) t! = x|t|=n (t) t! = (n 1)! 2n1 , result found kreimer {$9901099$} using combinatorial arguments. nal example, consider runge-kutta method a(u, v) = 1, b(u) = 1 gives (t) = 1 trees t. equation x(s) xed point problem x(s) = exp(x(s)), whose well-known solution x(s) = xn sn n! nn1, (t)t! = nn1. x|t|=n 5.3 antipode examples show b-series used generating series sums trees. hopf algebra structure art entails antipode s. (t) homomorphism, action antipode written s()(t) = (s(t)). runge-kutta method au, b, runge-kutta method = s() u = au b, bs = b. useful see working simple cases: u ((cid:31)) = 1 = u( ) s(!) = bs(s u () = s() = b(s u (")) = b(u(#)) = ( ) v ()) = au(v()) b(v()) = u() () u ()) = ( ) + b(1)(.) = (/) + (0)(1) u (s 5.4 convolution convolution dened (t) = ( )(t) = m. let au, b au, b runge-kutta methods of, respectively, (t) (t). specic, consider u varies 0 1. runge-kutta method au, b, u varies 0 2 au(xv) = au(xv) au(xv) = 0 au(xv) = b(xv) au(xv) = au1(xv1) b(xv) = b(xv) b(xv) = b(xv1) 0 u 1 0 v 1 0 u 1 1 v 2 1 u 2 0 v 1 1 u 2 1 v 2 0 v 1 1 v 2. 11 again, show formula action: u(2) = 1 (3) = b(1) + b(1) = (4) + (5) u(6) = au(v (7)) = au(1)1(u) + (b(1) + au1(1))1{$9810087$}(u) (8) = b(au(1)) + b((b(1) + au1(1))) = b(u(9)) + b(1)b(1) + b(u(:)) = (;) + (<)(=) + (>). 6 runge-kutta methods renormalization section, shall follow closely kreimers paper {$9901099$} dene, operation homomorphisms, corresponding transformation runge-kutta methods. instead attempting general theory, consider specic example detail. 6.1 runge-kutta method bare quantities consider given bare physical quantity calculated sum trees, corresponding runge-kutta method found pair linear operators au b. usual combinatorial proof show solution equations (we take s0 = 0) where, usually, xu(s) = x0 + sau x(s) = x0 + sb, xu(s) = x0 +xt x(s) = x0 +xt u(?) = 1 s|t| |t|! s|t| |t|! (t)t!aut (t)t!(t)t, u(b+(t1 tk)) = au . . . au (t) = b. x(s) sum giving bare quantity interest. broadhurst kreimer {$9810087$}, quantity interest examples developed x(s) = xt s|t| |t|! bt, bt obtained recursively given bn b = b1 bt = b|t|t1t2 tk = b+(t1, t2, , tk). (10) renormalization problems considered broadhurst kreimer, bn dened function l() regular (and equal 1) origin, bn = l(n) n . 12 pair operators giving (t) = bt dened au(xv) = 1 z u 0 l( dv v)xv, b(xv) = a1(xv). quantity interest x(s) obtained tensoring au simple integral method obtain (t) = bt/t!. thing need following action au monomial vn1 au(vn1) = 1 z u 0 l( dv v)vn1 = 1 z u 0 vn1dvl(n) = bnun. (11) 6.2 sr, renormalized antipode following results section 5.3, runge-kutta method sr() obtained u (x) = au(x) ha1(x)i, bs(x) = ha1(x)i. runge-kutta method working rst examples using eq.(11), nd, ref.{$9901099$}, kreimer denes recursively renormalized antipode3 depending renormaliza- tion scheme r. take example toy model used kreimer, r = hi projection pole part laurent series inside bracket. u () = 1 s(a) = ha1(1)i = hb1i u (b) = au(v(c)) ha1(v(d))i = au(1) ha1(1)i = b1u hb1i s(e) = ha1(s u (f))i = hb2b1i + hhb1ib1i. 6.3 renormalized quantities finally, renormalized quantities xr(s) obtained convolution sr() . obtain corresponding runge-kutta method, use results section 5.4. however, domain 1 u 2 used, runge-kutta method renormalized quantity ar u (x) = au(x) ha1(x)i, br(x) = a1(x) ha1(x)i. may seem surprising simple equation encodes full combinatorial complexity renormalization. even necessary work examples out, ar u (x) u (t), dierence comes action br. r u (x) = u (t) = real calculation xr(s), need ar u br give us (t) = (t), tensor product method simple integral method obtain (t) = t!(t). detail, equation renormalized quantity xr(s) x r uu (s) = xr(s) = 0 z u z 1 0 0 dvz u dvz 1 0 dvl(vv)exvv (s) h dvl(vv)exvv (s)i (12) dvl(vv)exvv (s) h dvl(vv)exvv (s)i. (13) 0 z 1 z 1 dvz u dvz 1 0 0 0 general renormalization scheme r, one replaces hau(x)i r. finally, chens lemma renormalization schemes {$9901099$} obtained hairer wanners theorem eq.(5). 7 renormalization kreimers toy model section, use runge-kutta methods renormalized explicitly kreimers toy model even functions l(). {$9810087$}, remarkable properties renormalized sum diagrams connes-moscovici weights noticed. 3in hopf algebra terms sr()(t) = r. 13 7.1 equation renormalized quantity role sum u eq.(13) add factor 1/t!, section5.2.4. therefore, uu (s) fact function su reasoning used show x r write x r u (s) found eq.(13) relation x r u (su), denes function x r us(1) u (s). equation x r uu (s) = x r u (s) = x r x r u (s) = xr(s) = 1 0 z u z 1 0 1 0 dvz dvz 0 dsl(vv)exv (s) h dsl(vv)exv (s) h 0 1 z 1 z 1 0 1 0 dvz dvz 0 dsl(vv)exv (s)i (14) dsl(vv)exv (s)i. (15) solve equation, expand x r u (s) power series u: x r u (s) = an(s)un. xn=0 standard identity gives us exp(x r n(a)un, u (s)) = xn=0 n(a) = x||=n a1 1 n 1! n! || = a1 + 22 + + nn. n(a) depends arguments ai(s). sets given n obtained partitions n: (1, . . . , n), 1 n n = n, = i+1 < n. rst n(a) 0(a) = 1 1(a) = a1 2(a) = a2 + a2 1 2 3(a) = a3 + a1a2 + a3 1 6 . 7.2 solution equation introducing series expansions x r u (s) exp(x r u (s)) eq.(15) obtain xn=0 an(s)un = xn=0 bn+1z 0 ea0(s)n(a)dsun+1 h xn=0 bn+1z 0 ea0(s)n(a)dsi a0(s) = h xn=0 an(s) = bnz 0 bn+1z ea0(s)n1(a)ds 0 ea0(s)n(a)dsi n > 0. (16) solve equation, need go back equation bare quantity x 0 u(s) = 1 z u 0 dvz 0 dsl(vv)ex 0 v (s). (17) x 0 u(s) function su, dene x 0(s) = x 0 (1) satises x 0(s) = 1 z 0 du u z u 0 14 dvl(vv)ex 0(v). solution equation given b-series x 0(s) = xn nsn n = x|t|=n (t)bt |t|! . (18) hand, also expand ex 0(v) using functions n(a). identifying sides eq.(18), obtain relation = bn n n1(a). identity, prove that, renormalized quantities, an(s) = (g(s))nan, g(s) =z 0 exp(a0(s))ds. (19) (20) since 0(a) = 1 = b1, equation true n = 1, eq.(16). eq.(20) true n 1, n1(a) = (g(s))n1n1(a) derivative eq.(16) gives us an(s) = bnea0(s)n1(a) = bng(s)(g(s))n1n1(a) = n(g(s))n1an, ow bare quantity: x r eq.(19). integrating equation condition an(s) = 0 gives eq.(20) level n. proved ow renormalized quantity reparametrization u (s) = a0(s) + x 0(ug(s)) x r(s) = a0(s) + x 0(g(s)). determine a0(s) proceed step step. eq.(18) expand l(vv) . rst term 1, obtain eq.(9) solution x(s) = 2 log(1 s/(2)). renormalized quantity, singular term becomes x 0(g(s)) = 2 log(1 g(s)/(2)). since x r(s) regular, singular term must compensated corresponding term a0(s). equating singular terms obtain a0(s) = 2 log(1 g(s)/(2)). know eq.(20) a0(s) = log(g(s)), obtain singular terms solution g(s) = 1/(1 g(s)/(2))2, is: g(s) = 1 + 2 a0(s) = 2 log(1 + 2 ). expanding a0(s) series s, obtain singular term observed {$9810087$} proved {$9901099$}. one notices singularity non-pertubative term a0(s) logarith- mic, much smoother singularities coming expansion (i.e. perturbative expression). 7.3 dierential equation nite part general, one proceed next singular term. obtain denote (s) = x 0(g(s)), change variable gives equation (s): (s) = 1 z 0 g(u)du g(u) z u 0 dvg(v)l( + g(v) g(v) v)ey (v). write (s) = x r(s)a0(s), notice term a0(s) left-hand side compensated term right-hand side l = 1 exp(x r(s)) = 1. obtain equation x r(s): x r(s) = 1 z 0 du u(1 + u 2 )z u 0 dv(cid:20) 1 (1 + v 2 )2 l(vv + v2 2 v)(1 + 2 ) v 2 ex r(v) 1(cid:21) . nice aspect previous equation seems limit goes zero. fact, limit l even, shall show now. 15 writing x(s) = lim0 x r(s), taking limit 0 previous equation, obtain x(s) = 2z 0 or, dierential form: du u2 z u 0 dv(cid:20) 1 v2 l( v2 2 v)v2e x(v) 1(cid:21) , (s2 x(s)) = 1 2 1 s2 l( s2 2 ds )s2e x(s) 1. x(s) l() expanded x(s) = bnsn l() = 1 + xn=1 l( s2 2 ds ) = 1 + ln( s2 2 ds )n, xn=1 lnn, sothat xn=1 (21) obtain following relation term s: b1s = (b1 + l1/2)s. l1 zero, obtain contradition must proceed withdrawal divergences. simplicity, shall assume l1 = 0. b1 becomes free parameter x(s). terms bn n > 1 determined b1 ln (n > 1). terms regular. {$9810087$}, function l() taken even. l1 = 0, results correspond b1 = 0. broadhurst kreimer also used function l(, ). present treatment applied general situation, change ln = n! lim 0 lim 0 dn dn l(, ). clearly, eq.(21) much faster solve computing sum trees. instance, expansion could calculated 20 loops (i.e. b20) within seconds computer. 7.4 alternative point view alternative way solve eq.(17) bare quantity. dene function f (s) l() f (s) = l(n + ) n! sn = l( ds s)es. xn=0 relation f (s) l() also established mellin transforms f l (f )(z) = (l)( z)(z). f (s) write equation bare quantity x 0(s) = dvf (x 0(v)). (22) 1 z 0 du u z u 0 alternatively, one go f l consider results toy model method renormalize equations type (22). 8 n-dimensional problems applications classical eld theory, need develop runge-kutta methods n-dimensional analogue ow equation: non-linear partial dierential equations. purpose present section indicate b-series used case4. method apply equations form l(r) = f , l dierential operator (e.g. nonlinear schrodinger equation = 3). 4kreimer independently aware possibility use b-series non-linear partial dierential equations. 16 8.1 formulation need two starting elements: function 0(r) solution l0(r) = 0, green function g(r, r), solution equation lrg(r, r) = (r r), given boundary conditions. function 0(r) play role initial value, green function decide direction move initial value. also state, sense, boundary conditions solution (r). using two functions, dierential equation l(r) = f  transformed (r) = 0(r) +r drg(r, r)f . action l enables us go second combinatorics standard runge-kutta method, result rst equation. (r) = 0(r) +xt (t)t! |t|! z drg(r, r)r (t), r(t) dened recursively r(g) = f  r( ) = f i (23) (24) r(b+(t1 tk)) = f (k)z dr1g(r, r1)r1 (t1) z drkg(r, rk)rk (tk). vector eld, solution same, equations (24) get indices: r(b+(t1 tk)) = f j1...jk z dr1gj1 j 1 (r, r1)j 1 r1 (t1) z drkgjk j k (r, rk)j k rk (tk), gi j(r, r) component matrix green function. previous sections, series (3) written function (t) (describing eect runge-kutta method (a,b)) (describing eect function f ). present case, separation longer possible, (t) combines pieces information. 8.2 examples section, equation (23) applied one-dimensional problem schrodinger equation. 8.2.1 one-dimensional case instructive observe one-dimensional case obtained eq.(23). dierential operator l = d/ds, initial function 0(s) must satisfy d/ds0(s) = 0: 0(s) constant write x0. green function g(s, s), equation lg(s, s) = (s s), g(s, s) = (s s) + c(s), (s) step function c(s) function s. determine c(s), note that, simple integral method, integral s0 s. green function g(s, s) = (s s) (s0 s), obtain required expression. z g(s, s)f (s)ds = z s0 f (s)ds now, role 0 green function clear one-dimensional case: 0 gives initial value x0 g species (among things) starting point s0. complete derivation one-dimensional case, note 0(s) = x0 depend s, terms f (k) = f (k) independent grouped together build (1). hand, integration green functions build (s s0)|t|/t! obtain eq.(2). 17 8.2.2 schrodinger equation write schrodinger equation (e + )(r) = v (r)(r), apply eq.(23) f  = v (r). take 0(r) solution (e + )0(r) = 0 g(r, r) scattering green function (e.g. g(r r) = eie|rr |/(4|r, r|) three dimensions). calculation (t) straightforward because, linear problem, f (k) = 0 k > 1. hence, rooted trees survive one branch. trees (t) = 1 t! = |t|! obtain (r) = 0(r) +z dr1g(r, r1)v (r1)0(r1) +z dr1dr2g(r, r1)v (r1)g(r1, r2)v (r2)0(r2) + recognize born expansion lippmann-schwinger equation. 8.2.3 schrodinger equation ii also treat schrodinger equation alternative way system equations: (e + )(r) = v ()(r) rj = ij . matrix dierential equation. give index 0 rst line, index (running 1 dimension space) lines, called space lines. purpose space lines ensure = r. standard trick take r dependence v account expansion (see e.g. {$9810022$} p.143). initial value take 0(r) 0 = 0, matrix green function diagonal equal scattering wave function line 0 (ri ri) (ri) line i. r(), zero-th component v (0)0(r) space components 1, r() = v (0)2z drg(r, r)0(r) +xi r() = v (0)3z dr1g(r, r1) + v (0)z drg(r, r)xi r() = 2v (0)xi trees, space components 0 zero-th component simplest tree riiv (0)z drg(r, r)0(r) +xij riiv (0)0(r) rirjijv (0). riiv (0)0(r) expressions become complex, derivation made systematic recurrence relation. 9 conclusion butchers approach runge-kutta methods applied simple renormalization problems. since cayley, clear art ideally suited treat dierentials. conrmed presenting b-series solution class non-linear partial dierential equations. recursive nature b-series make computationally ecient: u(t) ob- tained simple operation u(t) smaller order t. b-series automated implemented computer. butchers approach still much oer. numerical analysis literature, b-series generalized treat ow equations lie groups. main change  replace algebra rooted trees algebra planar trees (also called ordered trees 18 ). elementary dierentials get quantized calculus avor, especially denition given munthe-kaas {$9810087$} terms commutators vector eld f = f ii (see also ginocchio). using generalized art, extended work carried recently numerical solution dierential equations lie groups (see ref. web site http://www.math.ntnu.no/num/synode). b-series generalized directions, e.g. stochastic dierential equations {$9810087$} dierential equations type dy/ds = f (y, z), g(y, z) = 0, called dierential algebraic equations {$9810087$}. hope butchers approach applied quantum eld theory. 10 acknowledgements great pleasure thank dirk kreimer alain connes interest, encouragement discussions. 11 appendix 11.1 coproduct reference, action coproduct antipode rst trees given here. 1 = 1 1  = 1 + 1   = 1 + 1 r +s u =v 1 + 1 w +x +z [ \ = 1 + 1 ^ +_` + 2b =e 1 + 1 f +g h +i j +k    = 1 + 1  + 2  +  + v w =x 1 + 1 +z { +| } +~ (cid:127) +(cid:129) + = 1 + 1 + 3 + 3 (cid:141) +   19 11.2 antipode s(1) = 1 s() =  s(cid:16)(cid:17) =  + s(cid:18)(cid:19) = + 2 (cid:157) s(cid:16)(cid:17) = + 2 = + 2 + 3(cid:173) +  ! =   + 2 + 3 + ! = + + + 3 + s(cid:16)(cid:17) = + 3 3 + 